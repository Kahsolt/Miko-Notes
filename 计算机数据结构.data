考研复习：数据结构

零.概览
1.基本概念
概念
  数据		信息载体，符号集合
  数据元素	一条记录，由若干数据项组成
  数据对象	具有相同性质的数据元素的集合，当前考察的数据集
  数据类型	原子类型/结构类型/抽象数据类型
  抽象数据类型	ADT::=(数据对象, 数据关系, 基本操作集)
  数据结构	逻辑结构+存储结构+数据运算
三要素
  逻辑结构
    线性：线性表、栈/队列/串、数组/广义表
    非线性：集合、树、图/网
  存储结构
    顺序存储	逻辑相邻=>物理相邻
    链式存储	逻辑相邻=>物理可不相邻
    索引存储	增加索引表::=(关键字，首地址)
    散列存储	物理地址由关键字决定：首地址=Hash(关键字)
  数据运算
    定义+实现

2.算法及评估
算法：确定、有穷、可行、输入*、输出+
时间复杂度T(n)=O(f(n))
空间复杂度S(n)=O(g(n))

一.线性表
线性表
  顺序存储：线性表
  链式存储：单链表/双链表/循环链表、静态链表
顺序表示
  int *list=malloc(LEN*sizeof(int));
链式表示
  typedef struct node {
    int data;
    struct node* next;
  } Node;

二.栈与队列
受限线性表
  栈：顺序栈、链栈、共享栈
  队列：循环队列、链式队列、双端队列
  数组：一维数组、多维数组、广义表
栈
  #define push(x) stack[++top]=x
  #define pop() stack[top--]
  #define top() stack[top]
  栈的混洗：卡塔兰数Catalan=C(n,2n)/(n+1), 分子C为组合数符号
队列
  #define enqueue(x) queue[head++]=x
  #define dequeue() queue[tail++]
数组
  对称矩阵：
  下三角矩阵：k=i(i-1)/2+j-1
  三对角矩阵：k=2i+j-3
  稀疏矩阵=>(行i, 列j, 值v)

三.树与二叉树
1.树
术语
  关系：祖先节点/子孙节点、双亲节点/孩子节点、兄弟节点
  序：交换两个子树不影响称为无序树，否则有序
  度：本节点下的子节点个数
    分支节点/非终端结点的度>0
    叶子节点/终端结点的度=0
    树的度=max{degree(Ni), ...}
  层次：以根节点为第1层
    节点深度：从根开始累计到本节点
    节点高度：从某个叶子开始累计到本节点
    树高度/深度=最大层次数
  路径：两个节点之间若按有向边可达则该节点序列组成路径，所经过的边数量为路径长度
    树的路径长度：从根到每个节点的路径长度之和
    *树的边是有向的，从根向叶；因此沿着路径层次数总是单调增加
性质
  1.节点数=所有节点度/分支数之和+1
  2.度数为m的的树第i层上最多有m^(i-1)个节点
  3.高度为h的m叉树最多有(m^h-1)/(m-1)个节点(等比数列求和)
  4.具有n个节点的m叉树最小高度为[logm(n*(m-1)+1)]，其中[]向上取整
  或记为如下：
    T.nodes=sum(Ni.degree)+1
    对于T[degree=m], 有MaxNodes(N[layer=i])=m^(i-1)
    对于T[height=h]，有MaxNodes(T)=(m^h-1)/(m-1)
    对于T[nodes=n, degree=m]，有MinHeight(T)=ceil(logm(n*(m-1)+1))
  节点-分支关系：
    节点数=sum(Ni)=N0+N1+N2+...+Nm
    分支数=sum(i*Ni)=1*N1+2*N2+...+m*Nm
    节点数=分支数+1

2.二叉树(有序!)
特殊二叉树
  满二叉树	每一层都含有最多的节点，共2^h-1个节点
  完全二叉树	满二叉树的最后一层不满、连续缺失直到层尾，若含有度为1的节点则仅有此一个且是作为左儿子
  二叉排序树	左子树中所有节点关键字小于等于根节点，右子树则是大于，且子树均为二叉排序树
  平衡二叉树	任意节点的左右子树高度差不大于1
二叉树性质
  叶节点数=度为2的节点数+1(N0=N2+1)	// 由节点-分支关系推出
顺序存储
  int *tree=malloc((N+1)*sizeof(int));	// 有效节点下标从1开始
  *适合满二叉树：tree[i]的孩子时tree[2*i]和tree[2*i+1]
链式存储
  typdef struct node {
    int data;
    struct node *left, *right;	// n个节点的树含有(n+1)个指针空域
    int ltag, rtag;	// 线索二叉树使用
  } Node;

3.遍历与线索化
先序遍历：栈
  stack.push(root)
  while not stack.empty() do
    declare p=stack.pop()
    print p.data
    stack.push(p.left) if p.left
    stack.push(p.right) if p.right
  end
中序遍历：栈
  declare p=root
  while p or not stack.empty() do
    if p then
      stack.push(p)
      p=p.left
    else
      p=stack.pop()
      print p
      p=p.right
    end
  end
后序遍历
  # TODO
线索化
  遍历一次二叉树，对于指针空域，修改tag=1并指向遍历序列中的前驱或后继
  之后同序遍历不再借助栈，而看线索

4.树与森林
树存储结构
  双亲表示法		nodes[Ni]=(data, parent)
  孩子/邻接表表示法	nodes[Ni]=List(data1, data2, ...)；组织为广义表，孩子节点们链接成链表
  孩子兄弟/二叉树表示法	node::=(data, firstChild, nextSibling)；组织为二叉链表，孩子、兄弟分别链接成链表
转换
  树->二叉树	每个节点的左指针指向第一个孩子节点，右指针指向同层相邻的兄弟节点(转换后的二叉树根没有右孩子)
  森林->二叉树	每棵树转为二叉树，再依次作为前一棵二叉树根的右子树(同上，本无右孩子)
  二叉树->森林	逆操作，依次切断根节点的右子树，直到分离出的新树没有右子树
遍历
  先根遍历	先访问根，然后依次遍历每棵子树；等价于相应二叉树的先序遍历
  后根遍历	先依次遍历每棵子树，然后访问根；等价于相应二叉树的中序遍历
并查集：双亲表示法
  void inital(S) { for(int i=1;i<=N;i++) set[i]=i; }
  int find(x) { return set[x]==x ? set[x]=find(x) : x; }
  int union(x, y) { set[x]=y; }
  
5.应用
二叉排序树BST
  定义：左子树节点值<根节点值<右子树节点值，各子树都是BST
  查找：类似线性表上二分查找
  插入：在查找的退出点插入新节点(左右儿子都初始化为NULL)
  删除
    z为叶节点	直接删
    z有一个孩子	儿子过继给父节点
    z有两个孩子	// 看着办吧:(
平衡二叉树AVL
  平衡因子=左子树高度-右子树高度	// AVL的平衡因子只能是{0, 1, -1}
  插入：调整最小不平衡子树，即插入路径上离插入节点最近的平衡因子绝对值大于1的节点为根的子树
    LL平衡/右单旋转
    RR平衡/左单旋转
    LR平衡/先左后右
    RL平衡/先右后左
  查找：MaxHeight(T[nodes=n])=lb(n)；记高度为h的AVL树最少节点数为N(h)，则有递推公式N(h)=N(h-1)+N(h-2)+1
哈弗曼树Huffman/最优二叉树
  带权路径长度WPL=sum(Wi*Li)	// Wi是叶节点权值，Li是叶节点深度
  构造：贪心算法，每次合并两个权值最小的节点
  编码：从根节点开始左转记0右转记1

四.图
1.基本概念
定义：G=(V, E)	// V不可空，E可空
术语
  有向	E称为弧，有序对<v, w>
  无向	E称为边，无序对(v, w)
  简单	不存在重复边，不存在指向自己的边
  多重	允许两个节点之间多条边，允许指向自己的边
  完全	任意两个顶点之间都存在边(无向完全图共n(n+1)条边)
  子图	边和点都取子集并且构成合理的图，称为子图；点集相同，边集取子集称为生成子图
  连通	两个顶点(v, w)存在路径则连通，任意两点间存在路径则为连通图
  连通分量	无向图中，每一个极大连通子图
  强连通分量	有向图中，每一对顶点都连通
  生成树/森林	包含全部定点的极小连通子图
  度/出入度	顶点所连接的边数
  边权	边上可带权值，此时图称为网
  稀疏图	|E|<|V|*log|V|
  路径/回路	两个顶点之间可达的顶点序列；简单图有n个顶点，大于等于n条边则必有回路
  简单路径/回路	顶点不重复的路径/除了首尾其他顶点不重复的回路
  距离	顶点间若可达，则最短路径长度称为距离；否则为无穷大
  有向树	顶点入度为0，其余点入度为1的有向图

2.存储与操作
邻接矩阵
  int f[N][N]=Wij;
邻接表
  typedef struct edge {
    int vertex;	// 存顶点id
    struct edge *next;
  } Edge;
  typedef struct vertex {
    int id;
    struct edge *edges;
  } Vertex[N];
十字链表
  顶点数组横向展开拉出同起点的邻接点列表，纵向用链表串联相同终点的节点
邻接多重表
  (玄学?)

4.应用
最小生成树MST：最终边数=n-1
  Prim：类似于Dijkstra，每次选距离当前局部MST最近的点；O(V^2)，适合边多
  Kruskal：每次贪心选择最短的边，且增加该边不产生回路；O(|E|*log|E|)适合点多
最短路径
  Dijkstra：每次选最近的点，并更新源点若路由此点到其他点的距离；O(|V^2|)
  Floyd：计算所有点路由所有点的距离更新；O(|V|^3)
拓扑排序/关键路径：有向无环图DAG
  AOV网：顶点表示活动，有向边<Vi, Vj>表示活动i优先于j的关系
  AOE网：顶点表示状态，有向边表示活动事件；
    关键路径：从源点到汇点的路径中最长的路径
    关键活动：关键路径上的活动
    时间点
      事件最早发生时间ve(k)	// 从源点V到Vk最短路径时间
      事件最迟发生时间vl(k)	// 不推迟后续事件最早发生时间的最迟发生时间
      活动最早开始时间e(i)
      活动最迟开始时间l(i)
      活动浮动时间d(i)=l(i)-e(i)	// 浮动时间d(i)=0的活动构成关键路径

五.查找
1.基本概念
平均查找长度ASL=sum(Pi*Ci)；Pi为查找元素i的概率，Ci为找到i所需的比较次数
方式：顺序查找/折半查找/分块查找(顺序索引查找)

2.B树与B+树
B树：多路平衡查找树
  tree=>       30 52
             /   |   \
          10 20  50  68 90
  定义
    0.节点孩子数最多为m称为B树的阶
    1.每个节点至多有m棵子树(即至多m-1个关键字)
    2.若根节点不是终结点，则至少有两棵子树
    3.除根节点外所有非叶节点至少有ceil(m/2)棵子树(即至少ceil(m/2)-1个关键字)
    4.所有非叶节点结构为(n, P0, K1, P1, K2, P2, ..., Kn, Pn)，Ki为关键字/Pi为指向孩子指针
    5.所有叶节点出现在同一层次上(所有节点平衡因子=0)，为不带信息的虚节点(实际上其父亲节点指向NULL)
  高度：对于T[keys=n, height=h, degree=m]
    1.T.height>=log(m, n+1)
    2.T.hight<=log(ceil(m/2), (n+1)/2)+1
  查找：找节点，在节点内二分搜索关键字
  插入分裂：取溢出节点关键字的中位数传递给父亲节点，余下的左半树和右半树被父亲节点中的中位数关键字分隔(可能导致树高度+1)
  删除合并：取兄弟或父亲节点的关键字来补(可能树高度-1)
    *每个节点关键字个数范围为[ceil(m/2)-1, m-1]
B+树：适应数据库的改进
   tree=>        60              85		(可按树多路查找)
                 /                 \
            10  20   60         77   85
           /     |     \        /      \
   list=> 10-> 16->20-> 60-> 69->77-> 80->85	(可按链表顺序查找)
  条件
    1.每个分支节点至多有m棵子树
    2.非叶根节点至少有两棵子树，其他分支节点至少有ceil(m/2)棵子树
    3.节点子树个数与关键字数量相等
    4.所有叶节点包含全部关键字及指向相应记录的指针，叶节点中关键字按大小排序，相邻叶节点也按大小顺序全部互链
    5.所有分支节点(索引的索引)中仅包含其各子节点(即下一级索引块)中的关键字的最大值及指向其子节点的指针
对比
  ^		B树			B+树
  keys:subtree	n:n+1			n:n
  keys(root)	[1, m-1]		[1, m]
  keys(nonroot)	[ceil(m/2)-1, m-1]	[ceil(m/2), m]
  叶节点	不含信息		含所有信息
  非叶节点	含信息			仅作索引
  搜索终止	任意节点找到即可	必须下降到根节点
  节点上关键字	不重复			会有重复(若干个局部最大值)

3.散列表
散列函数
  直接定址	addr=a*key+b
  除留余数	addr=key%p	// p为大素数
  数字分析	取数码出现较均匀的几位作地址
  平方取中	关键字平方后取中间若干位
  折叠		关键字分为若干段，计算其加和
冲突处理
  开放地址：Hi=(Hash(key)+di)%m	// m为散列表长，di为重定位偏移
    线性探测	di={1,2,3, ..., m-1}，即找目标地址下一个空闲处；会导致相邻堆积
    平方探测	di={1^2,-1^2,2^2,-2^2, ..., k^2,-k^2}，其中k<=m/2且k=4i+3；可避免堆积，但无法探测所有可能空闲的单元格
    再散列	di=Hash2(key)；最多探测m-1次又会回到原位
    伪随机	di=rand()
  拉链：所有同义词追加为一个链表
性能分析
  装填因子=已填充记录数n/散列表长m	// 越小可能的冲突越少

4.模式匹配
void next(char T[], int next[]) {
  int i=1, j=0;
  next[1]=0;
  while(i<T[0]) {	// T[0]为串长度
    if(!j||T[i]==T[j])
      next[++i]=++j;
    else
      j=next[j];
  }
}

六.排序
1.内排序
插入排序
  直接插入：取待排袁旭，顺序查找插入有序表
  折半插入：取待排元素，二分查找插入有序表
  希尔排序：按d跨度的划分子表，每趟对子表用直接插入排序，然后逐趟缩小d重复排序工作直到为1
交换排序
  冒泡排序：寻找所有逆序对并交换位置
  快速排序：每趟排序确定一个新的枢轴，使得小于/大于枢轴元素都在其左/右边
选择排序
  简单选择：选择最大/最小的元素并确定其最终位置
  堆排序：建立大/小根堆，逐个把元素放在堆顶重整，并缩小堆的长度
归并排序：多个有序表合并为更长的有序表
基数排序：分配+收集，关键字拆分为更小的子关键字并对各个子关键词排序

2.内排序对比
^		时间	空间	稳定性
直接插入	n^2	1	
冒泡		n^2	1
简单选择	n^2	1	x
希尔		-	1	x
快速		n*logn	logn	x
堆		n*logn	1	x
二路归并	n*logn	n
基数		d*(n+r)	r

3.外排序
总时间=内排序时间+外存读写时间+内归并时间
方法
  多路平衡归并/败者树
  置换选择排序：生成初始归并段
  最佳归并树

